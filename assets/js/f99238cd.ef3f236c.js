"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9973],{7084:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-3-ai-robot-brain/nav2-path-planning","title":"Nav2 Path Planning for Humanoids","description":"For a robot to move autonomously from one point to another, it needs a robust navigation system. In ROS 2, the standard solution is Nav2. Nav2 is a powerful, configurable navigation stack designed to get a robot to a desired goal pose safely and efficiently, while avoiding obstacles. While Nav2 excels with wheeled robots, adapting it for a bipedal humanoid requires special considerations due to humanoids\' unique locomotion capabilities and constraints.","source":"@site/docs/module-3-ai-robot-brain/03-nav2-path-planning.mdx","sourceDirName":"module-3-ai-robot-brain","slug":"/module-3-ai-robot-brain/nav2-path-planning","permalink":"/Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-robot-brain/nav2-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Mhammadkhan17/Physical-AI-Humanoid-Robotics-Course/tree/main/docs/module-3-ai-robot-brain/03-nav2-path-planning.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Nav2 Path Planning for Humanoids"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS: Hardware-Accelerated VSLAM","permalink":"/Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-robot-brain/isaac-ros-vslam"},"next":{"title":"Voice-to-Action with Whisper","permalink":"/Physical-AI-Humanoid-Robotics-Course/docs/module-4-vision-language-action/voice-to-action-whisper"}}');var t=n(4848),s=n(8453);const a={title:"Nav2 Path Planning for Humanoids"},r=void 0,l={},c=[{value:"Nav2 Core Architecture",id:"nav2-core-architecture",level:2},{value:"Humanoid-Specific Challenges with Nav2",id:"humanoid-specific-challenges-with-nav2",level:2},{value:"Adapting Nav2 for Humanoids: The Custom Controller Plugin",id:"adapting-nav2-for-humanoids-the-custom-controller-plugin",level:2},{value:"Other Customizations:",id:"other-customizations",level:3},{value:"Conceptual Workflow for Humanoid Navigation",id:"conceptual-workflow-for-humanoid-navigation",level:2}];function d(e){const o={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(o.p,{children:["For a robot to move autonomously from one point to another, it needs a robust navigation system. In ROS 2, the standard solution is ",(0,t.jsx)(o.strong,{children:"Nav2"}),". Nav2 is a powerful, configurable navigation stack designed to get a robot to a desired goal pose safely and efficiently, while avoiding obstacles. While Nav2 excels with wheeled robots, adapting it for a bipedal humanoid requires special considerations due to humanoids' unique locomotion capabilities and constraints."]}),"\n",(0,t.jsx)(o.p,{children:"This chapter explores Nav2's core architecture and how to customize it for humanoid robots."}),"\n",(0,t.jsx)(o.h2,{id:"nav2-core-architecture",children:"Nav2 Core Architecture"}),"\n",(0,t.jsxs)(o.p,{children:["Nav2 is not a single program but a collection of modular servers and nodes that work together, often coordinated by a ",(0,t.jsx)(o.strong,{children:"Behavior Tree (BT) Navigator"}),"."]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Behavior Tree Navigator"}),": This is the high-level orchestrator. Instead of rigid finite state machines, Nav2 uses flexible Behavior Trees to define the robot's navigation logic. Common tasks include:","\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:(0,t.jsx)(o.code,{children:"ComputePathToPose"})}),": Plan a global path."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:(0,t.jsx)(o.code,{children:"FollowPath"})}),": Execute the path locally."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Recovery Behaviors"}),": Handle situations like getting stuck (e.g., ",(0,t.jsx)(o.code,{children:"ClearCostmap"}),", ",(0,t.jsx)(o.code,{children:"Spin"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Planner Server"}),":","\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Role"}),": Computes a collision-free path from the robot's current position to a distant goal. This is the ",(0,t.jsx)(o.strong,{children:"global path"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Algorithms"}),": Uses global planning algorithms like A* or Dijkstra's algorithm."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:(0,t.jsx)(o.code,{children:"global_costmap"})}),": Operates on the global costmap, a large map of the environment used for long-range planning."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Controller Server"}),":","\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Role"}),": Executes the global path by generating short-term velocity commands (",(0,t.jsx)(o.code,{children:"geometry_msgs/Twist"}),") to send to the robot's base. This is the ",(0,t.jsx)(o.strong,{children:"local trajectory"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Algorithms"}),": Uses local planning algorithms like Dynamic Window Approach (DWA) or Timed Elastic Band (TEB)."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:(0,t.jsx)(o.code,{children:"local_costmap"})}),": Operates on a smaller, constantly updated costmap around the robot for immediate obstacle avoidance."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Costmap Filters/Layers"}),": Both global and local costmaps are built from multiple layers (e.g., static map, obstacle layer from sensor data, inflation layer to keep robot clear of obstacles)."]}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"humanoid-specific-challenges-with-nav2",children:"Humanoid-Specific Challenges with Nav2"}),"\n",(0,t.jsx)(o.p,{children:"Nav2 was primarily designed for differential-drive or omnidirectional wheeled robots. Humanoids, however, present several challenges:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Locomotion Model"}),": Wheeled robots use ",(0,t.jsx)(o.code,{children:"Twist"})," messages (linear x/y, angular z velocity). Humanoids use complex gait patterns, foot placement, and balance control to walk. They cannot simply spin in place or strafe as easily."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Footprint"}),": A wheeled robot usually has a simple circular or rectangular footprint. A humanoid's footprint changes as it walks, and its arms/legs can extend beyond its base, making obstacle avoidance more complex."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Recovery Behaviors"}),': Simple recovery behaviors like "spin 360" are often not applicable or safe for a humanoid.']}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"adapting-nav2-for-humanoids-the-custom-controller-plugin",children:"Adapting Nav2 for Humanoids: The Custom Controller Plugin"}),"\n",(0,t.jsxs)(o.p,{children:["The most significant adaptation required for humanoid navigation with Nav2 is to implement a ",(0,t.jsx)(o.strong,{children:"Custom Controller Plugin"}),"."]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Concept"}),": Instead of providing a ",(0,t.jsx)(o.code,{children:"geometry_msgs/Twist"})," directly, your custom controller receives the desired global path from the Nav2 Planner. It then translates this path into commands suitable for the humanoid's specific locomotion controller."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Input"}),": The custom controller plugin still subscribes to the global path from the Planner Server and uses the ",(0,t.jsx)(o.code,{children:"local_costmap"})," for immediate obstacle detection."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Output"}),": Instead of publishing ",(0,t.jsx)(o.code,{children:"Twist"})," messages, your custom controller might:","\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["Publish to a ",(0,t.jsx)(o.code,{children:"/humanoid_walking_commands"})," topic with custom message types (e.g., desired step length, walking speed, turn rate)."]}),"\n",(0,t.jsxs)(o.li,{children:["Call a ROS 2 service exposed by the humanoid's low-level gait controller (e.g., ",(0,t.jsx)(o.code,{children:"set_gait_parameters"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"other-customizations",children:"Other Customizations:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Costmap Footprint"}),": You will need to carefully define a more accurate, perhaps dynamic, ",(0,t.jsx)(o.code,{children:"footprint"})," for the humanoid in your Nav2 configuration. This ensures that the costmaps correctly represent the robot's physical extent and prevent collisions with its limbs."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Behavior Tree Nodes"}),': You might need to add custom Behavior Tree nodes for humanoid-specific recovery behaviors. For instance, a "take a step back" action might be more appropriate than a simple "spin" if the humanoid gets too close to an obstacle.']}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"conceptual-workflow-for-humanoid-navigation",children:"Conceptual Workflow for Humanoid Navigation"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Goal Request"}),": A user or higher-level AI sends a goal pose (x, y, yaw) to Nav2 (e.g., via RViz or an action client)."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Global Planning"}),": The Nav2 Planner Server computes a global path to this goal using the ",(0,t.jsx)(o.code,{children:"global_costmap"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Local Control (Custom)"}),": Your custom Humanoid Controller Plugin receives this global path."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Locomotion Command Generation"}),": Based on the robot's current pose, joint states, and the local costmap, your custom controller determines the necessary walking commands (e.g., where to place the next foot, how fast to swing the legs, balance adjustments)."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Low-Level Execution"}),": These walking commands are sent to the humanoid's low-level gait controller, which then actuates the individual joint motors to perform the walk."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Feedback"}),": Odometry from the robot (e.g., from an IMU and joint encoders) is fed back into Nav2 for continuous localization."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"While integrating humanoids with Nav2 adds a layer of complexity, the modularity and extensibility of the Nav2 stack make it feasible. By focusing on a well-designed custom controller plugin and carefully configured costmaps, you can leverage Nav2's robust capabilities for path planning and obstacle avoidance in bipedal robots."})]})}function h(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>r});var i=n(6540);const t={},s=i.createContext(t);function a(e){const o=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:o},e.children)}}}]);