---
id: python-rclpy-bridge
title: Python rclpy Bridge
slug: /module-01-ros2/04-python-rclpy-bridge
---

While ROS 2 core components are often implemented in C++ for performance, `rclpy` provides a Python client library that allows developers to easily interface with ROS 2 from Python. This is particularly useful for rapid prototyping, high-level control logic, and integrating with AI frameworks.

## Introduction to rclpy

`rclpy` is the Python binding for `rcl` (ROS Client Library), which is a C library that exposes the ROS 2 API. This means `rclpy` nodes can seamlessly communicate with C++ nodes and leverage the full capabilities of ROS 2.

### Why use rclpy?

*   **Ease of Use**: Python's syntax and extensive libraries make it ideal for quick development.
*   **AI Integration**: Many AI/ML frameworks (e.g., TensorFlow, PyTorch) are Python-native, making `rclpy` a natural bridge.
*   **Readability**: Python code is generally more readable, aiding in collaboration and maintenance.

## Creating a ROS 2 Python Node

Creating a ROS 2 node in Python involves importing `rclpy` and defining a class that inherits from `rclpy.node.Node`. Inside this class, you can create publishers, subscribers, service servers, and service clients.

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher_node')
        self.publisher_ = self.create_publisher(String, 'my_topic', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.count = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2 from Python! Count: {self.count}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.count += 1

def main(args=None):
    rclpy.init(args=args)
    node = SimplePublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Bridging Python Agents to ROS Controllers

In Physical AI, `rclpy` is crucial for allowing intelligent Python-based agents (e.g., reinforcement learning agents, LLM-driven planners) to send commands to ROS-controlled hardware. The agent would publish desired actions (e.g., joint velocities, target poses) to ROS topics, which are then picked up by lower-level ROS controllers.

### Example Scenario:

1.  **Perception Node (C++)**: Publishes sensor data (e.g., camera images).
2.  **AI Agent Node (Python - `rclpy`)**: Subscribes to sensor data, processes it using an AI model, and publishes high-level commands.
3.  **Controller Node (C++)**: Subscribes to high-level commands and translates them into low-level motor control signals.

This seamless interoperability between Python and C++ allows developers to leverage the strengths of both languages in complex robotics applications.
