---
title: ROS 2 Nodes, Topics, and Services
---

Welcome to the nervous system of your robot! In the world of Physical AI, ROS 2 (Robot Operating System 2) acts as the essential middleware, allowing different parts of your robot's software to communicate and work together seamlessly. Think of it as the central nervous system that carries signals between the brain (your AI code) and the body (the robot's motors and sensors).

At the heart of any ROS 2 system are three core concepts: **Nodes**, **Topics**, and **Services**. Mastering these is the first step toward building complex and robust robotic applications.

## What is a ROS 2 Node?

A **Node** is the fundamental building block of a ROS 2 system. It is essentially a small, independent program that performs a specific task. You should design your robotic system as a collection of nodes, each with a single, well-defined purpose.

*   **Analogy:** Think of a robotic system like a team of specialists. You have one specialist for seeing (a camera node), another for hearing (a microphone node), one for moving a hand (an arm controller node), and one for thinking (a decision-making node). Each specialist is a node.

This modular approach makes your system easier to debug, reuse, and scale. For example, if you want to upgrade your robot's camera, you only need to replace the camera node; the rest of the system can remain unchanged.

### Example: A Simple Node with `rclpy`

Here is how you can create a basic node in Python using the `rclpy` (ROS Client Library for Python):

```python
import rclpy
from rclpy.node import Node

class MySimpleNode(Node):
    def __init__(self):
        super().__init__('my_first_node')
        self.get_logger().info('Hello from my first ROS 2 Node!')

def main(args=None):
    rclpy.init(args=args)
    node = MySimpleNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```
This code initializes `rclpy`, creates an instance of our `MySimpleNode`, and then `rclpy.spin(node)` keeps it running and responsive to ROS 2 events.

## Communication Methods: Topics vs. Services

Nodes are useful on their own, but their true power comes from communication. ROS 2 provides several ways for nodes to exchange data, with the two most common being Topics and Services.

### ROS 2 Topics: The Broadcast System

**Topics** are used for continuous, one-way data streams. They follow a **publish/subscribe** model. One or more nodes can **publish** (send) messages to a topic, and one or more nodes can **subscribe** (receive) messages from that same topic. The nodes themselves are decoupled and don't know about each other's existence.

*   **Analogy:** A topic is like a public radio station. A broadcaster (publisher) sends out a signal on a specific frequency (the topic name, e.g., `/weather_reports`). Any number of listeners (subscribers) can tune into that frequency to receive the broadcast. The broadcaster doesn't know who is listening, and the listeners don't know who the broadcaster is.

**Key Characteristics:**
*   **Asynchronous:** Publishers send data whenever they want, and subscribers listen whenever they can.
*   **Many-to-Many:** One topic can have multiple publishers and multiple subscribers.
*   **Use Case:** Ideal for streaming data from sensors, like camera images (`/camera/image_raw`), laser scans (`/scan`), or robot state (`/odom`).

#### Example: A Publisher and Subscriber

Here's a conceptual example of a publisher that sends a "Hello" message and a subscriber that listens for it.

**Publisher (`talker.py`):**
```python
# ... (imports and node setup)
class TalkerNode(Node):
    def __init__(self):
        super().__init__('talker')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.get_logger().info('Talker node has been started.')

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello World'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
```

**Subscriber (`listener.py`):**
```python
# ... (imports and node setup)
class ListenerNode(Node):
    def __init__(self):
        super().__init__('listener')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.get_logger().info('Listener node has been started.')

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')
```

### ROS 2 Services: The Request/Reply System

**Services** are used for two-way, synchronous communication. They follow a **request/reply** (or client/server) model. A **client** node sends a single request to a **server** node and waits for a single response.

*   **Analogy:** A service is like calling a function or making a REST API call. You send a specific request (e.g., `add(2, 3)`) and you pause your execution until you receive a specific response (e.g., `5`).

**Key Characteristics:**
*   **Synchronous:** The client blocks (waits) until the server provides a response.
*   **One-to-One:** A service call involves a single client and a single server.
*   **Use Case:** Ideal for triggering actions or requesting specific data, such as "move the robot arm to this position," "save the current map," or "calculate the distance to an obstacle."

#### Example: A Service Server and Client

Here's a conceptual example of a service that adds two integers.

**Service Server (`add_two_ints_server.py`):**
```python
# ... (imports and node setup)
# The service type AddTwoInts has a 'request' and 'response' structure
from example_interfaces.srv import AddTwoInts

class AddTwoIntsServerNode(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')
        self.server = self.create_service(
            AddTwoInts, 
            'add_two_ints', 
            self.add_two_ints_callback)
        self.get_logger().info('Service server has been started.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Returning sum={response.sum}')
        return response
```

**Service Client (`add_two_ints_client.py`):**
```python
# ... (imports and node setup)
# The client node sends a request and waits for the result
# ...
# In some function:
request = AddTwoInts.Request()
request.a = 5
request.b = 10
future = self.client.call_async(request)
rclpy.spin_until_future_complete(self, future)
response = future.result()
self.get_logger().info(f'Got response: {response.sum}')
```

## Summary: Topics vs. Services

| Feature         | Topics (Publish/Subscribe)                               | Services (Request/Reply)                                  |
|-----------------|----------------------------------------------------------|-----------------------------------------------------------|
| **Pattern**     | One-way broadcast                                        | Two-way query                                             |
| **Sync**        | Asynchronous (fire-and-forget)                           | Synchronous (client waits for response)                   |
| **Relationship**| Many-to-Many                                             | One-to-One                                                |
| **Use Case**    | Continuous data streams (e.g., sensor data, robot state) | Triggering remote actions, requesting computed data       |

By combining nodes that communicate via topics and services, you can build a distributed, modular, and powerful software system for any robot.
